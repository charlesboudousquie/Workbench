

void Behavior::TakeTask
{
  t->currentNode = this;
  t->parent = this->parent;
  t->child = this->GetChild();
}

void Behavior::GiveToChild(Task* t)
{
  // when task is given to child it is assumed that child
  // is receiving it for the first time so obviously it is
  // just starting up.
  t->PushPhase(BehaviorPhase::STARTING);
  t->PushChildIndex(0);
  GetCurrentChild()->TakeTask(t);
}

void Behavior::GiveToParent(Task * t)
{
  // we are going up the tree so we dont care about
  // what state we had in the lower tree(same for child index).
  t->Pop_Phase();
  t->PopChildIndex();
  
  // if parent exists then give task to them
  if(parent)
  {
    parent->take_task(t);
  }
}




Sequencer

void Behavior::Init()
{
  // verify that task is in STARTING phase when inside Init function
  assert(t->State == BehaviorPhase::STARTING);
}

void Sequencer::Init()
{
  //give task to first child
  GiveToChild(t);
}

void Sequencer::Update()
{
  // get child status
  auto result = child->GetResult();
  
  // if our child succeeded then move onto next one
  if(result == BehaviorPhase::SUCCESS)
  {
    // in each node we keep track of which child index we are using
    task->AdvanceCurrentChild();// childIndices.top()++;
    
    // if done with all child nodes then we succeeded
    if(task->CurrentChildIndex() == MAX)
    {
      task->SetResult(result);
      // Setting phase doesnt matter since we are leaving
      // this node.
      GiveToParent(task); 
    }
  }
  else if(result == BehaviorPhase::FAILURE)
  {
    task->SetResult(result);
    GiveToParent(task);
  }
}



















































