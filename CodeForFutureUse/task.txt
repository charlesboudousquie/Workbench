
class Task
{
  public:
  
  // NOTE:
  // We want multiple agents to use the exact same tree. 
  // What I mean by that is that if multiple agents (like a "Guard" or 
  // "Soldier") use the exact same tree, then ideally only 1 instanciation of 
  // that tree would be in memory.
  // But at the same time the agent need to remember what they are
  // doing aka their state. 
  // So if multiple agents use the exact same tree then they CANNOT store 
  // their state in the tree.
  // Thus they should store their state inside their own personal blackboard.
  // So then one may ask "How do we keep track of where exactly this
  // agent is inside the tree?".
  // This is where the "Task" comes in. 
  // It keeps track of what agent it corresponds to, AND keeps track of where 
  // in the tree the agent last left off.
  
  // If you are wondering why the childIndices and phases are stacks,
  // it is due to the fact that an Agent MUST remember its previous
  // states higher up in the tree. Especially since the nodes in the
  // tree are NOT allowed to store state. The nodes in the Behavior Tree
  // are essentially glorified instructions through which an agent acts upon.
  
  
  // add child index to keep track of
  void PushChildIndex(int newIndex);
  // increment child index by 1
  void IncrementChildIndex();
  // Of the node we are currently in (like a sequncer),
  // this will tell us the index of the child node we 
  // are operating on.
  int GetChildIndex();
  void PopChildIndex();
  
  void SetResult(BehaviorResult);
  BehaviorResult GetResult();
  
  // usually want to set phase during Behavior update() or Behavior exit()
  void SetPhase(BehaviorPhase);
  // usually want to push a new phase during Behavior init()
  void Push_Phase(BehaviorPhase);
  BehaviorPhase GetPhase();
  // only called when going back up to parent node
  void Pop_Phase();
  
  Agent* GetAgent();
  void SetAgent(Agent*);
  
  void SetChildBehavior(Behavior*);
  Behavior* GetChildBehavior();
  
  void SetParentBehavior(Behavior*);
  Behavior* GetParentBehavior();
  
  void SetCurrentBehavior(Behavior*);
  Behavior* GetCurrentBehavior();
  
  private:
    // parent node that we go to when 
    // done (potentially null if we are at the root).
    Behavior* parentBehavior;
    
    // Current Behavior Node we are operating on
    Behavior* currentBehavior;
    
    // The child of the current Node we are working
    // with (potentially null if we are a leaf node).
    Behavior* childBehavior;
    
    // The agent we will be working with
    Agent* agent;
    
    // NOTE: 
    // Since traversing a Behavior Tree is similar to depth
    // first search, we will be using stacks to remember
    // our state in higher nodes. This is helpful when an agent
    // finishes a particular behavior and needs to remember
    // what its last state was in the parent node.
    
    // top of stack corresponds to the index of the child node
    // of the current node we are working in.
    std::stack<int> currentChildStack;
    
    // Top of stack is the phase of current node we are in
    std::stack<BehaviorPhase> phases;
    BehaviorResult result;
}

void Task::PushChildIndex(int newIndex)
{ 
  currentChildStack.push(newIndex);
}

void Task::IncrementChildIndex()
{ 
  currentChildStack.top()++; 
}

int Task::GetChildIndex()
{ 
  return currentChildStack.top(); 
}

void Task::PopChildIndex()
{ 
  currentChildStack.pop(); 
}

void Task::SetResult(BehaviorResult r)
{
  result = r;
}
BehaviorResult Task::GetResult()
{
  return result;
}

// usually want to set phase during update() or exit()
void Task::SetPhase(BehaviorPhase p)
{
  phases.top() = p; 
  assert(phases.top() == p);// this better not be modifying a temporary
}

// usually want to push a new phase during init()
void Task::PushPhase(BehaviorPhase p)
{
  phases.push(p);
}

BehaviorPhase Task::GetPhase()
{
  return phases.top();
}

// only called when going back up to parent node
void Task::Pop_Phase()
{
  phases.pop();
}

Agent* Task::GetAgent()
{
  return agent;
}

void Task::SetAgent(Agent* agent_)
{
  agent = agent_;
}

